#+title: Rearrangement Candidate and Rearrangement Fusion Site Pipeline
#+author: Vince Buffalo
#+email: vsbuffalo@ucdavis.edu
#+date: 
#+babel: :results output :exports both :session :comments org

* Prerequistes

#+begin_src R +n :results silent :tangle analysis.R
  require(RSQLite)
  suppressMessages({
    require(ggplot2)
    require(Biostrings)})
  
  dbfile <- "samdb"
  
  # establish database
  drv <- dbDriver("SQLite")
  con <- dbConnect(drv, dbname=dbfile)  
    
  
#+end_src


* Split Mates: extracting candidate rearrangement partners

** Raw counts of reads mapped with one forward mate to chr11 and another mate mapped elsewhere.

#+begin_src R +n :tangle analysis.R
  query <- "
  SELECT chr_1, chr_2, strand_1, strand_2, count(*) as count
  FROM split_mates
  WHERE (chr_1 = 'chr11' OR chr_2='chr11') AND (mqual_1 > 30 AND mqual_2 > 30) 
  AND (strand_1 = 'forward')
  GROUP BY chr_1, chr_2, strand_1, strand_2;
  "
  all.counts <- dbGetQuery(con, query)
#+end_src

#+results:

** Instate basic count threshold: candidates with more than 10 counts

#+begin_src R +n :results output :tangle analysis.R
  count.thresh <- 10
  counts <- all.counts[all.counts$count > count.thresh, ]
  rownames(counts) <- NULL
  print(counts)
#+end_src

#+results:
:   chr_1 chr_2 strand_1 strand_2 count
: 1 chr11  chr2  forward  reverse   699
: 2 chr11  chr4  forward  reverse    11
: 3 chr11  chr6  forward  forward    76
: 4 chr11  chr8  forward  forward    15
: 5 chr11  chr9  forward  reverse  3027

** Positions of rearrangement candidate reads

Are there consistent positions of mapped reads in each rearrangement
candidate? Hierarchical clustering is used to group by distance.

#+begin_src R +n :tangle analysis.R
  
  extractCandidates = 
  # Given rows from the split_mates table subset for a candidate
  # rearrangement (same chr_2, other requirements met), cluster the
  # mapped alternate chromosome positions to form clusters of mapped
  # reads. Take a subset of these with a mapping count above the
  # threshold, extract their position range and total counts.
  function(reads.df, clust.member.thresh=2) {
    if (nrow(reads.df) == 0)
      return(NULL)
    pos <- reads.df$pos_2
    names(pos) <- pos
    h = hclust(dist(pos))
    groups <- cutree(h, h=10000)
    groups.counts <- table(groups)
    keep <- groups.counts[groups.counts > clust.member.thresh]
    
    if (length(keep) == 0)
      return(NULL)
    
    
    candidate.pos <- lapply(as.integer(names(keep)), function(x) {
      y <- groups == x
      r <- range(as.integer(names(groups))[y])
      return(list(range=r, count=sum(y)))
    })
  
    return(candidate.pos)
  }
  
  # template query for grabbing split mate rows
  read.query <- "
  SELECT *
  FROM split_mates
  WHERE chr_1 = 'chr11' AND mqual_1 > 30 AND mqual_2 > 30
  AND strand_1 ='forward'
  AND chr_2 = '%s' AND strand_2 = '%s';
  "
  
  # process all candidates from count thresholding step
  cands = apply(counts, 1, function(row) {
    cat(sprintf("extracting candidate rearrangement positions from %s\n", row[2]))
    d <- dbGetQuery(con, sprintf(read.query, row[2], row[4]))
    return(extractCandidates(d))
  })
  
  names(cands) <- counts$chr_2
#+end_src

* Split Reads: extracting possible fusion sites and confirming rearrangement partners

The other information in the paired end reads mapped to the entire
human genome are those that have one mate mapped and another
unmapped. BWA's short read aligner (unlike its long read aligner) will
not align only part of a read. Thus a read containing the fusion site
somewhere in the middle of its sequence will likely not map, since the
sequence will contain a large section of translocation chromosome.

The =unmapped_mates= table contains all reads in which one mate is
unmapped. Ordering by count, we see evidence of the same rearragement
partners as with the split-mates data:

#+begin_src R +n :tangle analysis.R
  query <- "
  SELECT mapped_chr, count(*) AS count FROM unmapped_mates 
  WHERE mapped_mqual > 30 GROUP BY mapped_chr ORDER BY count DESC;"
  fusion.counts <- dbGetQuery(con, query)
  print(fusion.counts)
#+end_src

#+results:
#+begin_example
   mapped_chr count
1       chr11 28218
2        chr2  6862
3        chr9  3590
4       chr21  3535
5        chr8  1223
6        chr6   767
7        chr1   563
8        chr5   422
9       chr12   414
10      chr22   357
11       chr4   350
12      chr17   295
13       chr3   294
14      chr16   265
15       chr7   238
16      chr20   237
17      chr14   199
18      chr15   160
19      chr19   155
20      chr18   103
21      chr10    94
22       chrX    93
23      chr13    89
24       chrY     3
#+end_example

The presumption here is that the unmapped mate will contain some
chromosome 11 (specifically MLL) sequence. We extract and map the
unmapped mates, keeping them grouped by the chromosome of their mapped
mate (which, if this were a true rearrangement, would be the
rearrangement partner).

#+begin_src R +n :tangle analysis.R
  writeFasta =
  # Write a fastafile, given headers and sequences.
  function(headers, sequences, filename) {
    if (length(headers) != length(sequences))
      stop("Arguments for headers and sequences must be same length.")
    con <- file(filename, open='w')
    for (j in 1:length(headers)) {
      cat(sprintf(">%s\n%s\n", headers[j], sequences[j]), file=con)
    }
    close(con)
  }
  
  
  check.dir =
  # if a directory doesn't exist, make it
  function(dir) {
    if (!file.exists(dir)) {
      message(sprintf("Making directory '%s'", dir))
      system(sprintf("mkdir -p %s", dir))
    }
    dir
  }
  
  
  query <- "
  SELECT mapped_chr as chr, name as header, unmapped_seq as seq 
  FROM unmapped_mates WHERE mapped_mqual > 30 ORDER BY mapped_chr;"
  
  # Get all Unmapped mates  
  unmapped.df <- dbGetQuery(con, query)
  unmapped.by.chr <- split(unmapped.df, unmapped.df$chr)
  
  fusion.read.dir <- check.dir("fusion-reads")
  
  for (chr in names(unmapped.by.chr)) {
    fn <- file.path(fusion.read.dir, sprintf("%s-fusion-candidates.fasta", chr))
    d <- unmapped.by.chr[[chr]]
    writeFasta(d$header, d$seq, fn)
  }
#+end_src

** BWA BWASW alignment of unmapped sequences

#+begin_src R +n :tangle analysis.R
  in.path =
  # Use a system call to which to check if a program is in the path.
  function(cmd) {
    if (system(sprintf("which %s", cmd)) != 0)
      FALSE
    TRUE
  }
  
  check.bwa = 
  # check that the reference is properly indexed
  function(refdir) {
    index.ext <- unlist(strsplit("amb;;ann;;bwt;;pac;;rbwt;;rpac;;rsa;;sa;;fasta", ';;'))
    contents <- dir(refdir)
    m <- sapply(contents, function(x) {
      tmp <- strsplit(basename(x), '\\.')[[1]]
      tmp[length(tmp)] %in% index.ext
    })
    
    if (!any(m))
      stop(sprintf("Reference in '%s' does not appear to be indexed.", refdir))
  }
  
  # check explicit path - allows this to work with org-mode with Emacs
  if (!any(c(in.path("bwa"), in.path("/usr/local/bin/bwa"))))
    stop("bwa not in path.")
  
  # check the reference has been indexed
  refdir <- "mll_template"
  ref <- file.path(refdir, "mll.fasta")
  check.bwa(refdir)

  # run long read aligner on all samples
  bwacmd <- "/usr/local/bin/bwa bwasw -T 10 -c 5 -t 3 %s %s > %s 2> /dev/null"
  aln.dir <- check.dir(file.path(fusion.read.dir, "alignments"))
  for (fasta.file in dir(fusion.read.dir, pattern="\\.fasta")) {
    chr <- unlist(strsplit(fasta.file, '-'))[1]
    aln.file <- file.path(aln.dir, sprintf("%s.sam", chr))
    system(sprintf(bwacmd, ref, file.path(fusion.read.dir, fasta.file), aln.file))
  }
#+end_src

#+results:
:  /usr/local/bin/bwa

** Processing alignment results with =find_fusion.py=

Now, we must parse the SAM results and find the fusion sites from
mapped reads with a CIGAR string of the format *x*M*y*S where *x* and
*y* are integers and M and S indicate mapped and soft-clipped bases.

This is done with =find_fusion.py= which uses pysam.

#+begin_src R +n :tangle analysis.R
  if (!any(c(in.path("python"), in.path("/usr/bin/python"))))
    stop("python not in path.")

  system(sprintf("ls %s/*sam | xargs -n1 python find_fusion.py", aln.dir))
#+end_src

#+results:
: /usr/bin/python
: /usr/bin/python


** Statistical analysis of fusion sites

We load each of these alignment files into the =hybid_candidates= table.

#+begin_src R +n :results silent :tangle analysis.R
  tbl.name <- "hybrid_candidates"
  
  # Remove any existing tables; otherwise we could load duplicates.
  if (dbExistsTable(con, tbl.name))
    dbRemoveTable(con, tbl.name)
  
  # Build a table
  cols <- c(chr='text', name='text', split='integer', mapped='text',
            softclipped='text', strand='text', mqual='integer')
  tbl.query <- dbBuildTableDefinition(drv, tbl.name, NULL, field.types=cols)
  dbGetQuery(con, tbl.query)
  
  # Load each dataframe into table
  for (f in dir(aln.dir, pattern="fusion-candidates\\.txt")) {
    chr <- strsplit(f, '-')[[1]][1]

    # wrap in try because some files will be completely empty.
    d <- try({read.csv(file.path(aln.dir, f), header=FALSE, sep='\t')}, TRUE)
    if (is(d, 'try-error') || !nrow(d))
      next()
    d <- cbind(chr, d)
    ok <- dbWriteTable(con, tbl.name, d, append=TRUE, row.names=FALSE)
    stopifnot(ok)
  }
#+end_src

What does the distribution of split points look like? Chromosome 11 is
presently excluded because its level of counts are much higher than
those of the other chromosomes.

#+begin_src R +n :tangle analysis.R
  query <- "SELECT chr AS chromosome, split, count(*) AS count
  FROM hybrid_candidates
  WHERE strand = 'forward'
  GROUP BY chr, split
  HAVING count > 20 ORDER BY count DESC;"
  
  split.df <- dbGetQuery(con, query)
  p <- ggplot(subset(split.df, chromosome!='chr11'), aes(x=split))
  p <- p + geom_histogram(aes(y=count, fill=chromosome), size=3, stat="identity", position='dodge')
  p <- p + scale_fill_brewer() #+ scale_x_continuous(limit=c(200, 250))
  p <- p + xlab("position") + ylab("count") 
  print(p)
#+end_src

#+results:

The chromosomes above are all rearrangement candidates. Now, write
FASTA files for each of these (again, for the moment excluding chr11) to
cluster.

#+begin_src R +n :tangle analysis.R
  cands <- split.df$chromosome[split.df$chromosome!='chr11']
  
  query <- "
  SELECT chr, name, softclipped FROM hybrid_candidates
  WHERE chr IN (%s);"
  
  tmp <- sapply(cands, function(x) sprintf("'%s'", x))
  seqs <- dbGetQuery(con, sprintf(query, paste(tmp, collapse=', ')))

  # divide by chromosome, write FASTA files
  seqs.by.chr <- split(seqs, seqs$chr)

  cluster.dir <- check.dir("hybrid-clusters")
  for (chr in names(seqs.by.chr)) {
    fn <- file.path(cluster.dir, sprintf("%s-clipped.fasta", chr))
    s <- seqs.by.chr[[chr]]
    if (nrow(s) > 0)
      writeFasta(s$name, s$softclipped, fn)
  }  
#+end_src

** Soft-clipped sequence clustering

Use =cd-hit= to cluster soft-clipped sequences (which in a
rearrangement will be the alternate chromosome). =cd-hit= produces
FASTA files of representative sequences, as well as .clstr files that
indicate cluster membership. To see how many sequences are clustered
into a single representative sequence, we extract the information from
the .clstr file.

#+begin_src R +n
  if (!any(c(in.path("cd-hit"), in.path("/usr/local/bin/cd-hit"))))
    stop("cd-hit not in path.")
  
  for (fasta.file in dir(cluster.dir, pattern="\\-clipped.fasta$")) {
    chr <- strsplit(fasta.file, '-')[[1]][1]
    fn <- file.path(cluster.dir, fasta.file)
    cfn <- file.path(cluster.dir, sprintf("%s-clusters.fasta", chr))
    ok <- system(sprintf("/usr/local/bin/cd-hit -i %s -o %s -g 1 -d 200 > /dev/null", fn, cfn))
    stopifnot(ok == 0)
  }
  
  processClstrFile =
  # cd-hit produces .clstr files with information on the cluster
  # sequences. This is the only way to (1) get the number of sequences
  # clustered in a representative sequence, and (2) get the header of
  # the representative sequence.
  function(filename) {
    contents <- readLines(filename)
    clusters <- list()
    first <- TRUE
    for (line in contents) {    
      if (length(grep('>Cluster', line))) {
        if (!first) {
          # push result to clusters list
          clusters[[header]] <- count
        } else {
          first <- FALSE
        }
        count <- 0
      } else {
        count <- count + 1
        parts <- unlist(strsplit(line, '\\s+'))
        if ('*' %in% parts) {
          header <- gsub('[^>]+>([^\\.]+).*', '\\1', line)
        }
      }
    }
  
    return(unlist(clusters))
  }
    
  # Grab representative sequences and corresponding clstr files and process.
  for (fasta.file in dir(cluster.dir, pattern="\\-clusters.fasta$")) {
    chr <- strsplit(fasta.file, '-')[[1]][1]
    fn <- file.path(cluster.dir, fasta.file)
    clstr.file <- file.path(cluster.dir, sprintf("%s.clstr", fasta.file))
  
    # process .clstr files
    rep.seqs <- as.data.frame(cbind(processClstrFile(clstr.file)))
  
    # read FASTA file
    clusters <- local({
      tmp <- readFASTA(fn, strip.descs=TRUE)
      headers <- lapply(tmp, function(x) x[[1]])
      seqs <- lapply(tmp, function(x) x[[2]])
      tmp <- as.data.frame(cbind(seqs))
      rownames(tmp) <- headers
      tmp
    })
  
    # match counts and sequence
    clusters <- merge(clusters, rep.seqs, by.x=0, by.y=0)
    clusters <- cbind(chr, clusters)
    colnames(clusters) <- c('chr', 'name', 'seq', 'count')
  
    print(clusters[clusters$count > 10, c('chr', 'seq', 'count')])
  }
  
#+end_src

#+results:
: /usr/local/bin/cd-hit
:     chr                                                      seq count
: 5  chr2 GCTGCTCCTACCCCCACTGGCCACTCTCTTTGAGCCAACTGGCCAAGAGCGGTCAC   215
: 18 chr2 TACTCTGAATCTCCCGCAGTGTCCTCTGCCTAGGACAAACCAGACCTTACAACTGT   171
:    chr                                                      seq count
: 1 chr8 TACTCTGAATCTCCTGCAGTGTCCTCTGCCTAGGACAAACCAGACCTTACAACTGT    33
:     chr                                                      seq count
: 1  chr9   TATCTAAACAGTGAGACTGGAGATACATTGTGCATTTTATATCCTGTTTTTTAT   748
: 16 chr9 TACTCTGAAGCTCCCGCAGTGTCCTCTGCCTAGGACAAACCAGACCTTACAACTGT    12





# order statistics?!
# select mapped_chr, count(*) as count from unmapped_mates 
# where mapped_mqual > 30 group by mapped_chr order by count desc;
